# Codestyle

## Abstract
1. Код должен быть простым, ясным и читаемым, в той мере, в которой это возможно для реализации требуемой функциональности.
2. Код должен быть самодокументируемым. Комментируйте только неочевидные вещи – костыли, воркэраунды, почему именно так сделано.
3. Нужно стремиться к минимизации статических методов и классов.

## Naming
1. Основной нейминга является кодстайл майкрософта: https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/naming-guidelines
2. Имена должны быть читабельными и понятными, без сокращений, аббревиатур и грамматических ошибок. Исключение – общепринятые сокращения, напр. i, j, k в циклах.
3. Методы, предназначенные для доступа к данным, в результате которых может вернуться null, должны иметь префикс Find
4. Методы, предназначенные для доступа к данным всегда возвращающие ненулевое значение, должны иметь префикс Get (и бросать ошибку, если не могут вернуть не null)
5. Методы, пытающиеся выполнить действие, но не обязательно выполняющие его, должны иметь префикс Try
6. Использовать studentCount и studentList вместо numberOfStudent, listOfStudent

## Variable and operator declaration
1. Для неочевидных числовых значений необходимо создавать именованные константы. Не используйте в коде магические числа
2. Используйте var, только если тип переменной понятен из контекста
3. Задавайте default в операторе switch. Если поведение не определено - кидайте исключение
4. При сравнении переменной с константой сначала указывается переменная, потом константа
5. Локальные переменные должны располагаться как можно ближе к месту использования
6. Минимизируйте уровень вложенности, где это возможно без потери читаемости. Этого можно добиться инвертированием условного оператора if, декомпозицией логики. https://refactoring.com/catalog/replaceNestedConditionalWithGuardClauses.html
7. Не используйте boolean флаги для того, чтобы управлять условиями выхода из цикла.

## Method declaration
1. Метод, возвращающий коллекцию, в случае отсутствия элементов для возврата, должен возвращать пустую коллекцию, а не null
2. Метод, который работает с пользовательскими аргументами, должен валидировать их
3. В конструкторе должен соблюдаться порядок инициализации:
   1. Валидация аргументов
   2. Инициализация, которая не зависит от аргументов
   3. Инициализация полей аргументами
   4. Инициализация, которая требует какой-то логики, вызовов методов

## Type declaration
1. Конструктор по умолчанию объявляйте явно
2. Конструкторы должны полностью инициализировать объект. Валидация аргументов должна происходить в конструкторах.
3. Минимизируйте область доступа к данным. Предпочтительней хранить информацию в приватных полях нежели в публичных свойствах. Методы, которые не нужны внешнему коду, нужно делать приватными.
4. Не оставляйте мутабельные поля для отложенной инициализации. Инициализируйте поля в конструкторах и делайте иммутабельные поля и свойства где это уместно.
5. Не использовать поля для передачи данных внутри метода или между методами класса.
6. Поддерживайте инвариант типа. Если у типа есть несколько полей, которые между собой связаны, то не должно быть способа изменить одно из полей и нарушить связь между ними.
7. Члены класса должны располагаться в следующем порядке: 
   - Константы
   - Поля
   - Свойства
   - Конструкторы и Create-методы
   - Публичные методы
   - Приватные методы
8. Нумерация значений енама должна начинаться с 1. 0 может быть использован для Undefined значений.
9. Не используйте приватные свойства.
10. Не используйте оператор `==` для сравнения не числовых типов. Не переопределяйте оператор `==` для не числовых типов
11. Не использовать наследование для переиспользования логики. Если объект наследуется, то справедливым должно быть высказывание, что производный объект является базовым (см. LSP).

## Exceptions
1. Все производные от Exception классы должны иметь постфикс "Exception"
2. Для ошибок бизнес логики стоит бросать кастомный эксепшен. Для стандартных ошибок, например невалидных аргументов, стоит использовать стандартные типы.
3. Нужно обрабатывать, где это оправдано, ошибки NRE, OutOfRange etc и вместо них бросать более понятные ошибки, которые описывают проблемную ситуацию.
4. Если ошибка не может быть обработана, то её необходимо прокидывать дальше, а не игнорировать.
5. Если возникает ошибка при валидации аргументов, то нужно указывать какой именно аргумент приводит к ошибке в тексте ошибки

# Common 
1. Методы расширения должны выделяться в специальные классы. Они должны иметь соответствующий постфикс Extensions.
2. Весь исходный код должен быть написан на английском. Это касается нейминга, комментариев и ошибок. Если есть необходимость использовать другой язык, то нужно применить инструменты локализации.
3. Для обозначения отсутствия значения стоит использовать null, а не default. Для значимых типов стоит возвращать Nullable<T>.
4. Избегайте кастов там, где можно их не использовать. Программа должна стримиться к повышению типизации и увеличении количества мест, где происходят проверки во время компиляции.
5. Минимизируйте количество ап кастов. Стараться не использовать более общие типы в сигнатурах, если они не поддерживаются.
6. При написании цепочки вызовов методов, разделяйте каждый вызов на отдельную строку
7. Для проверки на null использовать конструкции `is null` и `is not null`
8.  Используйте Type.Parse вместо Convert.ToType (например, int.Parse вместо Convert.ToInt32)

# Restrict
1. Не используйте dynamic
2. Не используйте goto
3. Не пишите касты для своих типов - implicit или explicit
4. Не используйте публичные вложенные типы
5. Не используйте модификатор доступа internal. Исключение - если нет возможности использовать другой.
6. Не используйте reflection для доступа к полям
7. Не используйте query-like LINQ
8. Не использовать Tuple, ValueTuple и KeyValueTuple в сигнатурах своих методов. Вводите специальные типы, которые лучше описывают данную структуру.
9. Не пишите в лямбдках больше одной операции, выносите сложную логику в методы
10. Не используйте char, short памяти. Большинство интерфейсов работают с int, а значит в коде появится много кастов, которые усложняют код.
11. Не используйте unsigned для гарантии, что значение будет больше нуля. Большинство интерфейсов работают с int, а значит в коде появится много кастов, которые усложняют код.
